IPC Design 

Queues.
















Public strongly typed messages are here .

This means the Program has no knowledge of the destination ( eg no reference) ..

And everything can talk to each other without needing a kernel reference

In some cases it is still wise to hide the messages 

Why messages

In no order . 

    /// 
    /// 1. Better checking of security and policy.  This can be placed at the entry point of a system rather than every method. It can also be fine grained eg service xyz cant talk to service abc.  Many exploits have come from lesser services  (eg Blaster worm via  SQL service )  , Media , and Web service then comprimising more fundamental system services like task scheduling. 
    /// 2. ! APIs never need to change and service changes are backward competible. 
    /// 3. ! Can invoke the destination thread waiting on a message without this code being in every method !!!
    /// 4. Can log and debug easier with a single point of entry.  Exceptions can be thrown but before leaving the scope of the service ( or app) can be logged and converted to a more flexible error message
    /// 5. ! Can be prioritized , allowing high thread priority tasks to jump the queue instead of blocking on a lock etc , 
    ///         this really helps provide better realtime support. High priority tasks ALWAYS win not like NT and Linux. (if Subsystes use priority ) 
    /// 6. Allow cross machine kernel to kernel messages 
    /// 7  Encourages fewer but chunkier calls in API design between services , instead of lots of small calls.
    /// 8. Allows easier Asynch calls which provide significant performance benefits
    /// 9. While a small perf hit in simple OS loop test in more complicated scenarios performance is better and more efficient due to Asynch nature.
    /// 10. Encourages non dependent call structures
    /// 11. Internal details are hidden and can be all internal ( or private)
    /// 12. Facilitates lego block design.
    /// 13. Prevent forging of information as 1) caller doenst create security (OS does)  , 2) we can clone on send. ( prevents other issues with direct call ) 
    /// 14. ErrorMessages can  be adjusted to suit the language and culture of the caller , while leaving the messages withing the subsystem english
    /// 15. Subsystems can be changed and restarted very easily. 


    /// 
    /// The negatives 
    /// 1. Requires an API wrapper for Synch operations 
    /// 2. It can be slower especially in tiny not real world benchmarks
	///	3.  When looking at the big picture apears more complex.