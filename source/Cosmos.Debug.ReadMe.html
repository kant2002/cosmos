<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
<head>
    <title>Untitled Page</title>
</head>
<body>

    <h2>
        Projects</h2>
    <h3>
        Comos.Debug.Common</h3>
    <p>
        Used by?</p>
    <h3>
        Comos.Debug.Consts</h3>
	
	    <p>
            Cosmos.Debug contains common classes and enums that runs on both Windows and 
            Cosmos. The Debugger uses it to receive messages from the debugstub in Cosmos, 
            and Cosmos uses it to compile into the debug stub.</p>
      <p>
            This unit should only contain constants and basic structures. No executable code 
            should exist in this assembly.</p>
      <p>
            References - The references should be absolutely minimal.....</p>
        <p>
            Because of this extreme care must be take of which assemblies are linked and 
            this assembly should not link in any other Cosmos assemblies.</p>
      <p>
            Cosmos.Compiler.Debug is a bit of misnomer, it should be renamed possibly in the 
            future (Constants? Common?). It is used by:</p>
      <ul>
        <li>DebugStub (running in Cosmos)</li>
        <li>Compiler (To communicate commands to the DebugStub over serial port)</li>
        <li>Cosmos.VS.Debug</li>
        <li>Cosmos.VS.Windows</li>
      </ul>
	
	    <h3>
            Comos.Debug.DebugStub</h3>
    <p>
        X# project which is compiled directly into Cosmos and executed on the target 
        machine. Communicates debug information back and forth to Visual Studio.</p>
    <p>
            I debated for a while if this was Kernel or Compiler. However the DebugStub must 
            remain isolated in nature, which is also why we rely on polling the serial 
            rather than IRQs. So in the end I decided since its debugging only and not part 
            of Cosmos itself, it is more appropriate in Compiler.</p>
    <h3>
        Comos.Debug.GDB</h3>
    <p>
        This is the older Cosmos GDB client. It is still useful in deep scenarios but is 
        now being overshadowed and replaced by the newer integerated assembly level 
        debuggers.</p>
    <h3>
        Comos.Debug.HostProcess</h3>
    <p>
            VS debugger requires a process that starts paused, and is then later started. To 
            do this and to unify the process that is used, we use a proxy process which then 
            controls the actual execution environment (VMWare, QEMU, etc).</p>
    <h3>
        Comos.Debug.VSDebugEngine</h3>
    <p>
        This provides a custom debug engine to Visual Studio to handle tracing, 
        breakpoints, stepping, watches, etc.</p>
        <ul>
            <li>AD7.Impl \ AD7Process.cs<ul>
                <li>Launches DebugHost, which then launches 
                VMWare etc</li>
                <li>Contains pipes for communicating to VMWare&#39;s serial port to DebugStub</li>
                </ul>
            </li>
            <li>BreakpointManager.cs<ul>
                <li>contains notes on breakpoints</li>
                </ul>
            </li>
        </ul>
	
	    <p>
            References</p>
    <ul>
        <li>http://archive.msdn.microsoft.com/debugenginesample/Release/ProjectReleases.aspx?ReleaseId=4149</li>
    </ul>
	
	    <p>
            &nbsp;</p>
    <p>
        &nbsp;</p>

</body>
</html>
