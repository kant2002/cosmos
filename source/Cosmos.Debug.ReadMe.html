<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
<head>
    <title>Untitled Page</title>
</head>
<body>

    <h2>
        Projects</h2>
    <h3>
        Comos.Debug.Common</h3>
    <p>
        &nbsp;</p>
    <h3>
        Comos.Debug.Consts</h3>
	
	    <p>
            Cosmos.Debug contains common classes and enums that runs on both Windows and 
            Cosmos. The Debugger uses it to receive messages from the debugstub in Cosmos, 
            and Cosmos uses it to compile into the debug stub.</p>
      <p>
            This unit should only contain constants and basic structures. No executable code 
            should exist in this assembly.</p>
      <p>
            References - The references should be absolutely minimal.....</p>
        <p>
            Because of this extreme care must be take of which assemblies are linked and 
            this assembly should not link in any other Cosmos assemblies.</p>
      <p>
            Cosmos.Compiler.Debug is a bit of misnomer, it should be renamed possibly in the 
            future (Constants? Common?). It is used by:</p>
      <ul>
        <li>DebugStub (running in Cosmos)</li>
        <li>Compiler (To communicate commands to the DebugStub over serial port)</li>
        <li>Cosmos.VS.Debug</li>
        <li>Cosmos.VS.Windows</li>
      </ul>
	
	    <h3>
            Comos.Debug.DebugStub</h3>
    <p>
        X# project which is compiled directly into Cosmos and executed on the target 
        machine. Communicates debug information back and forth to Visual Studio.</p>
    <p>
            I debated for a while if this was Kernel or Compiler. However the DebugStub must 
            remain isolated in nature, which is also why we rely on polling the serial 
            rather than IRQs. So in the end I decided since its debugging only and not part 
            of Cosmos itself, it belongs in Compiler.</p>
    <h3>
        Comos.Debug.GDB</h3>
    <p>
        &nbsp;</p>
    <h3>
        Comos.Debug.HostProcess</h3>
    <p>
            VS debugger requires a process that starts paused, and is then later started. To 
            do this and to unify the process that is used, we use a proxy process which then 
            controls the actual execution environment (VMWare, QEMU, etc).</p>
    <h3>
        Comos.Debug.VSDebugEngine</h3>
	
        <h4>
            Notes</h4>
        <ul>
            <li>AD7.Impl/AD7Process.cs does the lanching of the DebugHost, which then launches 
                VMWare etc</li>
            <li>BreakpointManager.cs contains notes on breakpoints</li>
        </ul>
	
	    <p>
            &nbsp;</p>
    <p>
        &nbsp;</p>

</body>
</html>
